/*
Test generated by RoostGPT for test java-unit-test using AI Type Open AI and AI Model gpt-4

Scenario 1: Test ProductMutationResolver Initialization
- Check if the ProductMutationResolver is initialized with the correct instance of ProductRepository.

Scenario 2: Test ProductMutationResolver With Null ProductRepository
- Check the behavior of the ProductMutationResolver when initialized with a null ProductRepository. The expectation is that it should throw an appropriate exception.

Scenario 3: Test ProductMutationResolver With Mocked ProductRepository
- Initialize ProductMutationResolver with a mocked ProductRepository and check if the functions of ProductRepository are being called correctly when the respective methods of ProductMutationResolver are invoked.

Scenario 4: Test ProductMutationResolver With Valid ProductRepository
- Initialize ProductMutationResolver with a valid ProductRepository and check if it is able to perform the operations correctly.

Scenario 5: Test ProductMutationResolver With Invalid ProductRepository
- Initialize ProductMutationResolver with an invalid ProductRepository (one which throws exceptions or returns incorrect data) and check if the ProductMutationResolver handles these cases correctly.

Scenario 6: Test ProductMutationResolver With Large Data
- Initialize ProductMutationResolver with a ProductRepository containing a large amount of data and check if it is able to handle the data efficiently.

Scenario 7: Test ProductMutationResolver With Empty ProductRepository
- Initialize ProductMutationResolver with an empty ProductRepository and check if it is able to handle such cases correctly. 

Scenario 8: Test ProductMutationResolver With Different Types of ProductRepository
- Initialize ProductMutationResolver with different types of ProductRepositories and check if it is able to handle all these different types correctly. 

Scenario 9: Test ProductMutationResolver Under Stress Conditions
- Initialize ProductMutationResolver with a ProductRepository and put it under stress by calling its methods multiple times rapidly. Check if it is able to handle the stress without breaking down. 

Scenario 10: Test ProductMutationResolver With Concurrent Access
- Initialize ProductMutationResolver with a ProductRepository and access it concurrently from multiple threads. Check if it is able to handle concurrent access correctly.
*/
package com.metsoft.ecommerce.api.mutation;

import com.coxautodev.graphql.tools.GraphQLMutationResolver;
import com.metsoft.ecommerce.model.Product;
import com.metsoft.ecommerce.repository.ProductRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Date;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class ProductMutationResolver_ProductMutationResolver_b00ea92333_Test {

    @Mock
    private ProductRepository productRepositoryMock;

    @InjectMocks
    private ProductMutationResolver productMutationResolver;
    
    @BeforeEach
    public void setUp() {
        productMutationResolver = new ProductMutationResolver(productRepositoryMock);
    }

    @Test
    public void testProductMutationResolverInitialization() {
        assertNotNull(productMutationResolver, "ProductMutationResolver should be initialized");
    }

    @Test
    public void testProductMutationResolverWithNullProductRepository() {
        assertThrows(NullPointerException.class, () -> new ProductMutationResolver(null));
    }

    @Test
    public void testProductMutationResolverWithMockedProductRepository() {
        Product product = new Product();
        product.setCreateDate(new Date());
        when(productRepositoryMock.save(any(Product.class))).thenReturn(product);

        Product savedProduct = productMutationResolver.saveProduct(product);
        assertEquals(product.getCreateDate(), savedProduct.getCreateDate());

        verify(productRepositoryMock, times(1)).save(any(Product.class));
    }

    @Test
    public void testProductMutationResolverWithInvalidProductRepository() {
        Product product = new Product();
        product.setCreateDate(new Date());
        when(productRepositoryMock.save(any(Product.class))).thenThrow(new RuntimeException());

        assertThrows(RuntimeException.class, () -> productMutationResolver.saveProduct(product));
        verify(productRepositoryMock, times(1)).save(any(Product.class));
    }

    @Test
    public void testProductMutationResolverDeleteProduct() {
        doNothing().when(productRepositoryMock).deleteById(anyInt());

        String result = productMutationResolver.deleteProduct(1);
        assertEquals("Product Deleted", result);

        verify(productRepositoryMock, times(1)).deleteById(anyInt());
    }
}
